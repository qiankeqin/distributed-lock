redlock
https://redis.io/topics/distlock
安全
1.互斥：相同时刻，只有一个客户端可以获取锁
2.无死锁：最终，即使锁定资源的客户端崩溃或获得分区，始终可以获取锁定。
3.容错：只要大部分Redis节点都能启动，客户端就可以获取和释放锁。

在Redlock之前，很多人对于分布式锁的实现都是基于单个Redis节点的。而Redlock是基于多个Redis节点（都是Master）的一种实现。
为了能理解Redlock，我们首先需要把简单的基于单Redis节点的算法描述清楚，因为它是Redlock的基础。

redlock算法存在问题：
	1.锁过期问题(客户A拿到锁执行了个超长时间的阻塞动作这个时间大于key的过期时间，这时候如果客户B去拿锁，会出现客户A和客户B同时有锁)
	2.本地时钟

*********************************************************************************
基于单Redis节点的分布式锁

首先，Redis客户端为了获取锁，向Redis节点发送如下命令：
SET resource_name my_random_value NX PX 30000
上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。

注意，在上面的SET命令中：

my_random_value是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。
NX表示只有当resource_name对应的key值不存在的时候才能SET成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。
PX 30000表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。
*********************************************************************************
最后，当客户端完成了对共享资源的操作之后，执行下面的Redis Lua脚本来释放锁：

if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
这段Lua脚本在执行的时候要把前面的my_random_value作为ARGV[1]的值传进去，把resource_name作为KEYS[1]的值传进去。

至此，基于单Redis节点的分布式锁的算法就描述完了。

*********************************************************************************
这里面有好几个问题需要重点分析一下。

首先第一个问题，这个锁必须要设置一个过期时间。否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分割（network partition）导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，
而其它客户端永远无法获得锁了。
antirez在后面的分析中也特别强调了这一点，而且把这个过期时间称为锁的有效时间(lock validity time)。
获得锁的客户端必须在这个时间之内完成对共享资源的访问。

第二个问题，第一步获取锁的操作，网上不少文章把它实现成了两个Redis命令：

SETNX resource_name my_random_value
EXPIRE resource_name 30
虽然这两个命令和前面算法描述中的一个SET命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX后崩溃了，那么就没有机会执行EXPIRE了，导致它一直持有这个锁。

第三个问题，也是antirez指出的，设置一个随机字符串my_random_value是很有必要的，它保证了一个客户端释放的锁必须是自己持有的那个锁。假如获取锁时SET的不是一个随机字符串，而是一个固定值，那么可能会发生下面的执行序列：

	客户端1获取锁成功。
	客户端1在某个操作上阻塞了很长时间。
	过期时间到了，锁自动释放了。
	客户端2获取到了对应同一个资源的锁。
	客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。
	之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了。
第四个问题，释放锁的操作必须使用Lua脚本来实现。释放锁其实包含三步操作：’GET’、判断和’DEL’，
用Lua脚本来实现能保证这三步的原子性。否则，如果把这三步操作放到客户端逻辑中去执行的话，就有可能发生与前面第三个问题类似的执行序列：

	客户端1获取锁成功。
	客户端1访问共享资源。
	客户端1为了释放锁，先执行’GET’操作获取随机字符串的值。
	客户端1判断随机字符串的值，与预期的值相等。
	客户端1由于某个原因阻塞住了很长时间。
	过期时间到了，锁自动释放了。
	客户端2获取到了对应同一个资源的锁。
	客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。
实际上，在上述第三个问题和第四个问题的分析中，如果不是客户端阻塞住了，而是出现了大的网络延迟，也有可能导致类似的执行序列发生。

前面的四个问题，只要实现分布式锁的时候加以注意，就都能够被正确处理。
但除此之外，antirez还指出了一个问题，是由failover引起的，却是基于单Redis节点的分布式锁无法解决的。

正是这个问题催生了Redlock的出现。

假如Redis节点宕机了，那么所有客户端就都无法获得锁了，服务变得不可用。
为了提高可用性，我们可以给这个Redis节点挂一个Slave，
当Master节点不可用的时候，系统自动切到Slave上（failover）。
但由于Redis的主从复制（replication）是异步的，这可能导致在failover过程中丧失锁的安全性。
考虑下面的执行序列：

	客户端1从Master获取了锁。
	Master宕机了，存储锁的key还没有来得及同步到Slave上。
	Slave升级为Master。
	客户端2从新的Master获取到了对应同一个资源的锁。
	于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。

总结就是，为了避免单点，我们把redis设计成主备
==================================================================|
master->slave架构				 

1.client1从master上拿到锁了，这时候需要master复制到slave（异步），master挂掉了    =================================
2.slave升级成master
3.client2这时刚好访问newMaster拿到了同一资源的锁，现在情况是client1，client2都有了这把锁    |=================================

	=================================							 =================================|
==================================================================|
【其它疑问】

前面这个算法中出现的锁的有效时间(lock validity time)，设置成多少合适呢？如果设置太短的话，锁就有可能在客户端完成对于共享资源的访问之前过期，从而失去保护；如果设置太长的话，一旦某个持有锁的客户端释放锁失败，那么就会导致所有其它客户端都无法获取锁，从而长时间内无法正常工作。看来真是个两难的问题。

而且，在前面对于随机字符串my_random_value的分析中，antirez也在文章中承认的确应该考虑客户端长期阻塞导致锁过期的情况。如果真的发生了这种情况，那么共享资源是不是已经失去了保护呢？antirez重新设计的Redlock是否能解决这些问题呢？


针对这个问题，antirez设计了Redlock算法


In the distributed version of the algorithm we assume we have N Redis masters. 
Those nodes are totally independent, so we don’t use replication or any other implicit coordination system. 
We already described how to acquire and release the lock safely in a single instance. 
We take for granted that the algorithm will use this method to acquire and release the lock in a single instance.
In our examples we set N=5, which is a reasonable value, 
so we need to run 5 Redis masters on different computers or virtual machines 
in order to ensure that they’ll fail in a mostly independent way.

需要5个独立的redis master
为了获取锁，客户端执行以下操作：
	1.它以毫秒为单位获取当前时间。
	2.它尝试在所有N个实例中顺序获取锁，在所有实例中使用相同的key和随机值。
		在步骤2中，当在每个实例中设置锁定时，客户端使用与总锁定自动释放时间相比较小的超时，以获取它。
		例如，如果自动释放时间为10秒，超时可能在〜5-50毫秒范围内。
		这样可以防止客户端长时间阻止与Redis节点进行通话：如果一个实例不可用，我们应该尝试尽快与下一个实例通话。
	3.客户端计算通过从当前时间中减去步骤1中获得的时间戳来计算获取所需的时间。
		当且仅当客户端能够在大多数实例中获取锁定（至少3个）时， 
		并且获取锁定的总时间小于锁定有效时间，则认为该锁被获取。
	4.如果锁被获取，则其有效时间被认为是初始有效时间减去经过的时间，如步骤3中所计算的。
	5.如果客户端由于某种原因无法获取锁（或者无法锁定N / 2个实例或者有效时间为负），它将尝试解锁所有实例（即使它认为它不能实例化锁定）。	
当然，上面描述的只是获取锁的过程，而释放锁的过程比较简单：客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。

由于N个Redis节点中的大多数能正常工作就能保证Redlock正常工作，
因此理论上它的可用性更高。我们前面讨论的单Redis节点的分布式锁在failover的时候锁失效的问题，
在Redlock中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响的。
具体的影响程度跟Redis对数据的持久化程度有关。

假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：

客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。
节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。
节点C重启后，客户端2锁住了C, D, E，获取锁成功。
这样，客户端1和客户端2同时获得了锁（针对同一资源）。

DistributedLock-db：基于数据库的悲观锁及乐观锁实现的分布式锁
应用：
悲观锁相比乐观锁更安全，并发高场景会导致阻塞大量连接。
乐观锁有死锁风险，需检查，占用数据库资源相比悲观锁要少。

DistributedLock-redis：基于redis实现的分布式锁
应用：
redlock不是绝对的安全。如果追求绝对的安全锁，redis的方式不可取。
DistributedLock-zookeeper：基于zookeeper实现的分布式锁
应用：
基于ZooKeeper的锁和基于Redis的锁相比在实现特性上有两个不同：

1.在正常情况下，客户端可以持有锁任意长的时间，这可以确保它做完所有需要的资源访问操作之后再释放锁。
这避免了基于Redis的锁对于有效时间(lock validity time)到底设置多长的两难问题。
实际上，基于ZooKeeper的锁是依靠Session（心跳）来维持锁的持有状态的，
而Redis不支持Sesion。
2.基于ZooKeeper的锁支持在获取锁失败之后等待锁重新释放的事件。这让客户端对锁的使用更加灵活。

锁的用途分为两种：
========================================================================================================
为了效率(efficiency)，协调各个客户端避免做重复的工作。即使锁偶尔失效了，只是可能把某些操作多做一遍而已，不会产生其它的不良后果。比如重复发送了一封同样的email。
为了正确性(correctness)。在任何情况下都不允许锁失效的情况发生，因为一旦发生，就可能意味着数据不一致(inconsistency)，数据丢失，文件损坏，或者其它严重的问题。
========================================================================================================
结论：
================================================================================================================
如果是为了效率(efficiency)而使用分布式锁，允许锁的偶尔失效，那么使用单Redis节点的锁方案就足够了，简单而且效率高。Redlock则是个过重的实现(heavyweight)。
如果是为了正确性(correctness)在很严肃的场合使用分布式锁，那么不要使用Redlock。它不是建立在异步模型上的一个足够强的算法，它对于系统模型的假设中包含很多危险的成分(对于timing)。
而且，它没有一个机制能够提供fencing token。那应该使用什么技术呢？Martin认为，应该考虑类似Zookeeper的方案，或者支持事务的数据库。
==================================================================================================================